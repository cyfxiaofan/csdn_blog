/**
 * CSDN首页中"图片轮播"和"导航展开"功能
 * @author  liuwei@csdn.net(瓜籽：可以再好一点点！)
 */
var csdn = csdn || {};
csdn.SwapImage = (function() {
    /**
     * 图片轮播
     * @param   [ Object ]   ops
     * @description
     *      ops.imgArray:   轮播图片
     */
    function _SwapImage(ops) {
        this.imgArray = ops.swapRoot.find('.J_adv');
        this.maxImgLength = this.imgArray.length;

        this.tagArray = null;
        this.currentImage = null;
        this.currentTag = null;
        this.nextImage = null;
        this.intervalTime = null;

        this.duration = 500; // 图片渐变的速度
        this.swapTime = 3000; // 图片交换的间隔
        this.index = -1; // 图片下标，默认从-1开始
        this.nextIndex = -1; // 下一张图片的下标，默认从-1开始

        this.init();
    };

    _SwapImage.prototype = {
        init: function() {
            var me = this;

            this.imgArray.each(function(i, item) {
                i == 0 ?
                    $(item).css({
                        'opacity': 1,
                        'display': 'list-item'
                    }) :
                    $(item).css({
                        'opacity': 0,
                        'display': 'none'
                    });
            });

            this.creatImgTags();
            setTimeout(function() {
                me.reCall.call(me);
                me.tagEvent.call(me);
                me.imgEvent.call(me);
            }, 1500);
        },

        /**
         * 重复调用swapImg()函数
         * @description
         *      方法之间需要重复调用swapImg()时，调用此方法
         */
        reCall: function() {
            var me = this;
            var img, nextIndex;

            this.index++;
            this.nextIndex = this.index + 1;
            this.currentImage = this.index < this.maxImgLength ? this.imgArray.get(this.index) : this.imgArray.get(0);
            this.nextImage = this.index < this.maxImgLength - 1 ? this.imgArray.get(this.index + 1) : this.imgArray.get(0);
            this.index = this.index < this.maxImgLength - 1 ? this.index : -1;
            this.nextIndex = this.nextIndex < this.maxImgLength ? this.nextIndex : 0;

            this.swapImg(this.currentImage, this.nextImage);
        },

        /**
         * 图片交换
         * @param   [ Object ]  cur
         * @param   [ Object ]  next
         * @description
         *      cur:    当前图片
         *      next:   下一张图片
         */
        swapImg: function(cur, next) {
            var me = this;

            // 消失效果
            this.animate({
                img: cur,
                opc: 0,
                complete: function() {
                    $(cur).css('display', 'none');
                    $(me.currentImage).css('opacity', '');
                }
            });

            // 显示效果
            $(next).css({
                display: 'list-item',
                opacity: 0
            });

            this.animate({
                img: next,
                opc: 1,
                complete: function() {
                    $(me.nextImage).css('opacity', '');
                    me.currentImage = next;
                    me.swapTag.call(me, me.nextIndex);
                    me.intervalCall();
                }
            });
        },

        /**
         * 交换功能动画
         * @param   [ Object ]  conf
         * @description
         *      conf.img:   当前图片
         *      conf.opc:   当前图片透明度
         */
        animate: function(conf) {
            var me = this;
            var img = $(conf.img);

            img.animate({
                opacity: conf.opc
            }, {
                duration: me.duration,
                easing: 'swing',
                step: function() {
                    var step = (typeof conf.step == 'function') ? conf.step : function() {};
                    step();
                },
                complete: function() {
                    var complete = (typeof conf.complete == 'function') ? conf.complete : function() {};
                    complete();
                }
            });
        },

        /**
         * 循环调用reCall()
         */
        intervalCall: function() {
            var me = this;

            this.intervalTime = setTimeout(function() {
                me.reCall.call(me);
                clearTimeout(me.intervalTime);
            }, this.swapTime);
        },

        /**
         * 创建图片对应的标志
         * @description
         *      根据图片的个数，创建对应的状态标志
         */
        creatImgTags: function() {
            var tagRoot = $('.js-tagRoot');

            for (var i = 0; i < this.maxImgLength; i++) {
                i == 0 ? tagRoot.append('<li class="current"></li>') : tagRoot.append('<li></li>');
            }
            this.tagArray = $('.slide-outer').find('li');
            this.currentTag = this.tagArray.get(0);
        },

        /**
         * 交换显示图片所对应的指示标志
         * @param   [ Number ]  index
         * @description
         *      index:  当前图片所对应标志的下标
         */
        swapTag: function(index) {
            var curTag = this.tagArray.get(index);

            this.currentTag && $(this.currentTag).removeClass('current');
            $(curTag).addClass('current');
            this.currentTag = curTag;
        },

        // 选择指示标志交换相应图片
        tagEvent: function() {
            var me = this;

            this.tagArray.each(function(i, item) {
                $(item).bind('click', function() {
                    if (!$(this).hasClass('current')) {
                        var cur = me.imgArray.get(i);
                        var next = me.imgArray.get(i + 1);

                        clearTimeout(me.intervalTime);
                        me.index = i - 1;
                        me.nextIndex = me.index + 1;

                        $(me.currentImage).stop(true, true);
                        $(me.nextImage).stop(true, true);

                        me.swapImg(me.currentImage, cur);
                        me.swapTag(i);
                    }
                });
            });
        },

        // 暂停图片轮播
        imgEvent: function() {
            var me = this;

            this.imgArray.each(function(i, item) {
                $(item).bind('mouseover', function() {
                    var over = me.imgArray.get(i);

                    $(over).stop(true, true);
                    clearTimeout(me.intervalTime);
                });

                $(item).bind('mouseout', function() {
                    me.intervalCall();
                });
            });
        }
    };
    return {
        swap: function(ops) {
            new _SwapImage(ops);
        }
    }
})();
// 出发轮播广告
var triggerSwap = setInterval(function(){
    if(window.CSDN && CSDN.track && CSDN.track.addAdvs){
        clearInterval(triggerSwap);
        CSDN.track.addAdvs();
    }
}, 500)
function number_transform(num) {
    var k = 1000;
    var m = 1000000;

    if (num >= m) {
        return Math.floor(num / m) + 'M';
    } else if (num > k) {
        return Math.floor(num / k) + 'K';
    } else {
        return num;
    }
};



/* ========================================================================
 * Bootstrap: carousel.js v3.0.0
 * http://getbootstrap.com/javascript/#carousel
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // CAROUSEL CLASS DEFINITION
  // =========================

  var Carousel = function (element, options) {
    this.$element    = $(element)
    this.$indicators = this.$element.find('.carousel-indicators')
    this.options     = options
    this.paused      =
    this.sliding     =
    this.interval    =
    this.$active     =
    this.$items      = null

    this.options.pause == 'hover' && this.$element
      .on('mouseenter', $.proxy(this.pause, this))
      .on('mouseleave', $.proxy(this.cycle, this))
  }

  Carousel.DEFAULTS = {
    interval: 5000
  , pause: 'hover'
  , wrap: true
  }

  Carousel.prototype.cycle =  function (e) {
    e || (this.paused = false)

    this.interval && clearInterval(this.interval)

    this.options.interval
      && !this.paused
      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))

    return this
  }

  Carousel.prototype.getActiveIndex = function () {
    this.$active = this.$element.find('.carousel-item.active')
    this.$items  = this.$active.parent().children()

    return this.$items.index(this.$active)
  }

  Carousel.prototype.to = function (pos) {
    var that        = this
    var activeIndex = this.getActiveIndex()

    if (pos > (this.$items.length - 1) || pos < 0) return

    if (this.sliding)       return this.$element.one('slid', function () { that.to(pos) })
    if (activeIndex == pos) return this.pause().cycle()

    return this.slide(pos > activeIndex ? 'next' : 'prev', $(this.$items[pos]))
  }

  Carousel.prototype.pause = function (e) {
    e || (this.paused = true)

    if (this.$element.find('.next, .prev').length && $.support.transition.end) {
      this.$element.trigger($.support.transition.end)
      this.cycle(true)
    }

    this.interval = clearInterval(this.interval)

    return this
  }

  Carousel.prototype.next = function () {
    if (this.sliding) return
    return this.slide('next')
  }

  Carousel.prototype.prev = function () {
    if (this.sliding) return
    return this.slide('prev')
  }

  Carousel.prototype.slide = function (type, next) {
    var $active   = this.$element.find('.carousel-item.active')
    var $next     = next || $active[type]()
    var isCycling = this.interval
    var direction = type == 'next' ? 'left' : 'right'
    var fallback  = type == 'next' ? 'first' : 'last'
    var that      = this

    if (!$next.length) {
      if (!this.options.wrap) return
      $next = this.$element.find('.carousel-item')[fallback]()
    }

    this.sliding = true

    isCycling && this.pause()

    var e = $.Event('slide.bs.carousel', { relatedTarget: $next[0], direction: direction })

    if ($next.hasClass('active')) return

    if (this.$indicators.length) {
      this.$indicators.find('.active').removeClass('active')
      this.$element.one('slid', function () {
        var $nextIndicator = $(that.$indicators.children()[that.getActiveIndex()])
        $nextIndicator && $nextIndicator.addClass('active')
      })
    }

    if ($.support.transition && this.$element.hasClass('slide')) {
      this.$element.trigger(e)
      if (e.isDefaultPrevented()) return
      $next.addClass(type)
      $next[0].offsetWidth // force reflow
      $active.addClass(direction)
      $next.addClass(direction)
      $active
        .one($.support.transition.end, function () {
          $next.removeClass([type, direction].join(' ')).addClass('active')
          $active.removeClass(['active', direction].join(' '))
          that.sliding = false
          setTimeout(function () { that.$element.trigger('slid') }, 0)
        })
        .emulateTransitionEnd(600)
    } else {
      this.$element.trigger(e)
      if (e.isDefaultPrevented()) return
      $active.removeClass('active')
      $next.addClass('active')
      this.sliding = false
      this.$element.trigger('slid')
    }

    isCycling && this.cycle()

    return this
  }


  // CAROUSEL PLUGIN DEFINITION
  // ==========================

  var old = $.fn.carousel

  $.fn.carousel = function (option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.carousel')
      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)
      var action  = typeof option == 'string' ? option : options.slide

      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
      if (typeof option == 'number') data.to(option)
      else if (action) data[action]()
      else if (options.interval) data.pause().cycle()
    })
  }

  $.fn.carousel.Constructor = Carousel


  // CAROUSEL NO CONFLICT
  // ====================

  $.fn.carousel.noConflict = function () {
    $.fn.carousel = old
    return this
  }


  // CAROUSEL DATA-API
  // =================

  $(document).on('click.bs.carousel.data-api', '[data-slide], [data-slide-to]', function (e) {
    var $this   = $(this), href
    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) //strip for ie7
    var options = $.extend({}, $target.data(), $this.data())
    var slideIndex = $this.attr('data-slide-to')
    if (slideIndex) options.interval = false

    $target.carousel(options)

    if (slideIndex = $this.attr('data-slide-to')) {
      $target.data('bs.carousel').to(slideIndex)
    }

    e.preventDefault()
  })

  $(window).on('load', function () {
    $('[data-ride="carousel"]').each(function () {
      var $carousel = $(this)
      $carousel.carousel($carousel.data())
    })
    $("#myCarousel").on('slide.bs.carousel', function(e){
      if(!$(e.relatedTarget).hasClass('trackviewed')){
        var trackData = $(e.relatedTarget).data('trackClick')
        csdn.report.viewCheck(trackData, $(e.relatedTarget), 100);
        $(e.relatedTarget).addClass('trackviewed')
        // console.log($(e.relatedTarget).index())
      }
    })
  })

}(window.jQuery);
